# 构造函数语义学习
> _**Author:邱雨波**_  
> _**2017年2月14日更新**_  

> 本节讨论关于构造函数的一系列问题。  

## **1.Default Constructor的构建操作**  
> C++新手一般有两个常见的误解:  
>
> 1. 任何class如果没有定义default constructor，就会被合成出来一个。:x:
> 2. 编译器合成出来的default constructor会明确设定class内的每一个data member的默认值。:x:

​	C++ Annotated Reference Manual中的section12.1告诉我们：“default constructor是在需要的时候才被编译器产生出来”。关键字眼——在被需要的时候。例如看下面一段例程：

```C++
//default constructor is produced when it is needed.
class DefaultFunctionClass{
public:  //no explicit constructor
	int a;
	int* p;
};

void test()
{
	DefaultFunctionClass d1; //no expilcit constructor

	//the default constructor will not initialize the d1.a=0
	cout <<"d1.a="<< d1.a << endl;// The variable 'd1' is being used without being initialized.

	if (d1.p == nullptr) // The variable 'd1' is being used without being initialized.
		d1.p = 0;
}
```
​	对于class X，如果没有任何user-declared constructor，那么会有一个defualt constructor 被暗中（impilcitly）声明出来，一个暗中被声明出来的default constructor 将是一个trivial constructor。C++ Standard然后开始一一叙述在什么样的情况下这个implicit default constructor 会被视为trivial。一个nontrivial default constructor 在ARM的术语中就是编译器所需要的那种，必要的话就会由编译器合成出来。下面四个小节分别讨论nontrivial default constructor的四种情况。
### **1.1带有default constructor的member class object**
​	如果一个class没有任何constructpr，但是它内涵一个member object，而后者有default constructor，那么class的implicit default constructor就是“nontrivial”，编译器需要为此class合成一个default constructor。不过这个合成操作只有在constructor真正需要被调用的时候才发生。

​	这就有了一个问题：在C++不同编译模块中，编译器如何避免合成多个default constructor呢？解决方法就是把合成的default constructor、copy constructor、destructor、assignment copy operator都以内联的方式完成。一个内联函数有静态链接，不会被档案以外的人看到。如果函数比较复杂，不适合作为内联函数，则合成一个expilcit non-inline static实体。

​	我们举个例子说明，在下面的程序片段中，编译器为class Bar合成了一个default cosntructor。

```C++
class Foo
{
public:
	Foo() {}
	Foo(int) {}
};

class Bar
{
public:
	Foo foo;   //not inherit ，it`s  include
	char* str;
};

void foo_bar()
{
	Bar bar; //Bar::foo must be initialized here
					//Bar::foo is a member class object ，and it has default costructors
}
```

​	 被合成的Bar default cosntructor内含有必要的代码，能够调用class Foo的default constructor来处理 member object Bar::foo，但并<u>不产生任何代码来初始化</u>。也就是说，**将Bar::foo初始化是编译器的责任，将Bar::str初始化则是程序员的责任。**被合成的default constructor看起来可能像这样：

```C++
//Bar`s default constructor may be as follow
inline Bar::Bar()
{
	//the C++ pseudo code
	foo.Foo::Foo();
}
```

​	这里，被合成的default constructor只满足编译器的需要，而不是程序员的需要。为了让这个程序片段能够正确的执行，字符指针str也需要被初始化。

### **1.2带有default constructor的base class**

​	类似的道理，如果一个没有任何constructor的class派生自一个带有default constructor的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它调用上层base class的default constructor。对一个后继派生的class而言，这个合成的constructor和一个“被明确提供的default constructor”没有什么差异。

### **1.3带有一个virtual function的class**

​	另有两种情况，也需要合成出default constructor：

1. class声明（或继承）一个virtual function。
2. class派生自一个继承串链，其中有一个或更多的virtual base classes。

### **1.4带有一个virtual base class 的class**

​	virtual base class的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共同点在于必须使virtual base class在其中一个derived class object中的位置，能够于执行期准备妥当。

### **1.5总结**

​	有四种情况，会导致“编译器必须为未声明constructor的classes合成一个default constructor”。C++ Standard把那些合成物称为implicit nontrivial default constructor。**被合成出来的constructor只能满足编译器（而非程序）的需要**。它之所以能完成任务，是借着“**调用**member object或base class的default constructor”或者是“为每一个object初始化其virtual function 机制或virtual base class机制”而完成。对于没有这四种情况且又没有声明任何constructor的classes，我们说它们拥有的是implicit trivial default constructor，它们实际上并不被合成出来。

​	**在合成的default constructor中，只有base class subobject和member class object会被初始化。所有其他的nonstatic data member，如整数、整数指针、整数数组等等都不会被初始化。这些东西初始化操作对于程序而言或许有需要，但对编译器则并非必要。如果一个程序需要一个“把某指针设置为nullptr”的default constructor，那么提供它的人应该是程序员**。

## **2.Copy Constructor的构建操作**

有三种个情况会调用到copy constructor：

1. 当一个object以另一个object为初值时。

   ```c++
   class X{};
   X x;
   X xx = x;//this will invoke copy constructor  
   ```

2. 当一个object被当做参数交给某个函数时。

   ```c++
   class X{};
   void func(X x);//not reference and pointer ,it is value
   void test()
   {
     X xx;
     func(xx);//there will invoke copy constructor
   }
   ```

3. 当函数传回一个class object时。

   ```c++
   class X{};
   X func();
   {
     X xx;
     return xx;//there will invoke copy constructor
   }
   ```