# 构造函数语义学习
> _**Author:邱雨波**_  
> _**2017年2月14日更新**_  

> 本节讨论关于构造函数的一系列问题。  

## **Default Constructor的构建操作**  
​	C++ Annotated Reference Manual中的section12.1告诉我们：“default constructor是在需要的时候才被编译器产生出来”。关键字眼——在被需要的时候。例如看下面一段例程：
```C++
//default constructor is produced when it is needed.
class DefaultFunctionClass{
public:  //no explicit constructor
	int a;
	int* p;
};

void test()
{
	DefaultFunctionClass d1; //no expilcit constructor

	//the default constructor will not initialize the d1.a=0
	cout <<"d1.a="<< d1.a << endl;// The variable 'd1' is being used without being initialized.

	if (d1.p == nullptr) // The variable 'd1' is being used without being initialized.
		d1.p = 0;
}
```
​	对于class X，如果没有任何user-declared constructor，那么会有一个defualt constructor 被暗中（impilcitly）声明出来，一个暗中被声明出来的default constructor 将是一个trivial constructor。C++ Standard然后开始一一叙述在什么样的情况下这个implicit default constructor 会被视为trivial。一个nontrivial default constructor 在ARM的术语中就是编译器所需要的那种，必要的话就会由编译器合成出来。下面四个小节分别讨论nontrivial default constructor的四种情况。
### **带有default constructor的成员类对象**
​	如果一个class没有任何constructpr，但是它内涵一个member object，而后者有default constructor，那么class的implicit default constructor就是“nontrivial”，编译器需要为此class合成一个default constructor。不过这个合成操作只有在constructor真正需要被调用的时候才发生。

​	这就有了一个问题：在C++不同编译模块中，编译器如何避免合成多个default constructor呢？解决方法就是把合成的default constructor、copy constructor、destructor、assignment copy operator都以内联的方式完成。一个内联函数有静态链接，不会被档案以外的人看到。如果函数比较复杂，不适合作为内联函数，则合成一个expilcit non-inline static实体。

​	我们举个例子说明，在下面的程序片段中，编译器为class Bar合成了一个default cosntructor。

```C++
class Foo
{
public:
	Foo() {}
	Foo(int) {}
};

class Bar
{
public:
	Foo foo;   //not inherit ，it`s  include
	char* str;
};

void foo_bar()
{
	Bar bar; //Bar::foo must be initialized here
					//Bar::foo is a member class object ，and it has default costructors
}
```

​	 被合成的Bar default cosntructor内含有必要的代码，能够调用class Foo的default constructor来处理 member object Bar::foo，但并<u>不产生任何代码来初始化</u>。